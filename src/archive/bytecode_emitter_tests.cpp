//#include "archive/bytecode_emitter_tests.h"
//
//#include <iostream>
//#include <iomanip>
//
//BytecodeEmitterTests::BytecodeEmitterTests()
//{
//	lexer = new Lexer;
//	parser = new Parser;
//	symbolResolution = new SymbolResolution;
//	semanticAnalysis = new SemanticAnalysis;
//	typeChecker = new TypeChecker;
//	emitter = new BytecodeEmitter;
//	nodeArena = new MemoryArena;
//	typeArena = new MemoryArena;
//	reporter = new DiagnosticReporter;
//
//	testSuite[TEST_PATH"/bytecode_emitter_tests/short_circuit_test.hollow"].testname = "short_circuit_test.hollow";
//	testSuite[TEST_PATH"/bytecode_emitter_tests/short_circuit_test.hollow"].expectedBytecode =
//	{
//		0x33, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x0b, 0x00, 0x01, 0x32, 0x00, 0x15, 0x00, 0x0b,
//		0x00, 0x00, 0x31, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x1f, 0x00, 0x00, 0x00,
//		0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x2d, 0x00, 0x0b, 0x00, 0x01, 0x31, 0x00, 0x34, 0x00,
//		0x00, 0x00, 0x0a, 0x30, 0x00, 0x37, 0x00, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x01, 0x31, 0x00,
//		0x4c, 0x00, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x4c, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x4f,
//		0x00, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x64, 0x00, 0x0b, 0x00, 0x01, 0x31,
//		0x00, 0x64, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x67, 0x00, 0x00, 0x00, 0x14, 0x0b, 0x00,
//		0x01, 0x31, 0x00, 0x83, 0x00, 0x0b, 0x00, 0x01, 0x31, 0x00, 0x83, 0x00, 0x0b, 0x00, 0x01,
//		0x31, 0x00, 0x83, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x86, 0x00, 0x00, 0x00, 0x14, 0x0b,
//		0x00, 0x00, 0x31, 0x00, 0xa2, 0x00, 0x0b, 0x00, 0x01, 0x31, 0x00, 0xa2, 0x00, 0x0b, 0x00,
//		0x01, 0x31, 0x00, 0xa2, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0xa5, 0x00, 0x00, 0x00, 0x14,
//		0x0b, 0x00, 0x01, 0x31, 0x00, 0xc1, 0x00, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xc1, 0x00, 0x0b,
//		0x00, 0x01, 0x31, 0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0xc4, 0x00, 0x00, 0x00,
//		0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0xd9, 0x00, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xd2, 0x00,
//		0x0b, 0x00, 0x00, 0x31, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0xe3, 0x00, 0x00,
//		0x00, 0x14, 0x0b, 0x00, 0x01, 0x32, 0x00, 0xf8, 0x00, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xff,
//		0x00, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xff, 0x00, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x02, 0x01,
//		0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x10, 0x01, 0x0b, 0x00, 0x01, 0x31, 0x00,
//		0x1e, 0x01, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x1e, 0x01, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x21,
//		0x01, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x3d, 0x01, 0x0b, 0x00, 0x01, 0x32,
//		0x00, 0x36, 0x01, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x3d, 0x01, 0x00, 0x00, 0x0a, 0x30, 0x00,
//		0x40, 0x01, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x01, 0x31, 0x00, 0x63, 0x01, 0x0b, 0x00, 0x00,
//		0x31, 0x00, 0x63, 0x01, 0x0b, 0x00, 0x01, 0x32, 0x00, 0x5c, 0x01, 0x0b, 0x00, 0x00, 0x31,
//		0x00, 0x63, 0x01, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x66, 0x01, 0x00, 0x00, 0x14, 0x0b, 0x00,
//		0x00, 0x31, 0x00, 0x74, 0x01, 0x0b, 0x00, 0x01, 0x31, 0x00, 0x74, 0x01, 0x0b, 0x00, 0x00,
//		0x32, 0x00, 0x82, 0x01, 0x0b, 0x00, 0x01, 0x31, 0x00, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x30,
//		0x00, 0x8c, 0x01, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x9a, 0x01, 0x0b, 0x00,
//		0x00, 0x31, 0x00, 0x9a, 0x01, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xb6, 0x01, 0x0b, 0x00, 0x01,
//		0x32, 0x00, 0xaf, 0x01, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xb6, 0x01, 0x00, 0x00, 0x0a, 0x30,
//		0x00, 0xb9, 0x01, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x01, 0x32, 0x00, 0xc7, 0x01, 0x0b, 0x00,
//		0x00, 0x31, 0x00, 0xe3, 0x01, 0x0b, 0x00, 0x01, 0x31, 0x00, 0xe3, 0x01, 0x0b, 0x00, 0x01,
//		0x32, 0x00, 0xdc, 0x01, 0x0b, 0x00, 0x00, 0x31, 0x00, 0xe3, 0x01, 0x00, 0x00, 0x0a, 0x30,
//		0x00, 0xe6, 0x01, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x02, 0x02, 0x0b, 0x00,
//		0x00, 0x31, 0x00, 0xf4, 0x01, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x02, 0x02, 0x0b, 0x00, 0x01,
//		0x31, 0x00, 0x09, 0x02, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x0c, 0x02, 0x00, 0x00, 0x14, 0x0b,
//		0x00, 0x01, 0x31, 0x00, 0x21, 0x02, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x21, 0x02, 0x00, 0x00,
//		0x0a, 0x30, 0x00, 0x24, 0x02, 0x00, 0x00, 0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x32, 0x02,
//		0x0b, 0x00, 0x01, 0x31, 0x00, 0x47, 0x02, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x40, 0x02, 0x0b,
//		0x00, 0x01, 0x31, 0x00, 0x47, 0x02, 0x00, 0x00, 0x0a, 0x30, 0x00, 0x4a, 0x02, 0x00, 0x00,
//		0x14, 0x0b, 0x00, 0x00, 0x32, 0x00, 0x58, 0x02, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x6d, 0x02,
//		0x0b, 0x00, 0x01, 0x32, 0x00, 0x66, 0x02, 0x0b, 0x00, 0x00, 0x31, 0x00, 0x6d, 0x02, 0x00,
//		0x00, 0x0a, 0x30, 0x00, 0x70, 0x02, 0x00, 0x00, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
//		0x34, 0x00
//	};
//}
//
//BytecodeEmitterTests::~BytecodeEmitterTests()
//{
//	delete parser;
//	delete lexer;
//	delete symbolResolution;
//	delete semanticAnalysis;
//	delete typeChecker;
//	delete emitter;
//	delete nodeArena;
//	delete typeArena;
//	delete reporter;
//}
//
//void BytecodeEmitterTests::runAll()
//{
//	logFile.open(TEST_PATH"/bytecode_emitter_tests/bytecode_emitter_log.txt");
//
//	std::cout << "===== Running Bytecode Emitter Test Suite =====\n";
//	for (auto const& [key, val] : testSuite)
//		runSpecific(key);
//
//	std::cout << std::endl;
//
//	logFile.close();
//}
//
//void BytecodeEmitterTests::runSpecific(const std::string& filename)
//{
//	lexer->reset();
//
//	if (!lexer->lexFile(TEST_PATH"/bytecode_emitter_tests/short_circuit_test.hollow"))
//		return;
//
//	parser->parse(lexer->getTokens(), nodeArena, reporter);
//	if (reporter->hasErrors())
//		return;
//
//	symbolResolution->resolve(parser->getAst(), reporter);
//	if (reporter->hasErrors())
//		return;
//
//	semanticAnalysis->analyze(parser->getAst(), typeArena, reporter, symbolResolution->getEnv(), symbolResolution->getTypeTable());
//	int globalVarCount = semanticAnalysis->getGlobalVarCount();
//	if (reporter->hasErrors())
//		return;
//
//	typeChecker->typeCheck(parser->getAst(), nodeArena, typeArena, reporter, symbolResolution->getTypeTable());
//	if (reporter->hasErrors())
//		return;
//
//	emitter->generateBytecode(parser->getAst());
//
//	const std::vector<uint8_t>* bytecode = emitter->getBytecode();
//	const std::vector<uint8_t>& expectedBytecode = testSuite[filename].expectedBytecode;
//	size_t expectedByteCount = expectedBytecode.size();
//	bool passed = true;
//
//	for (size_t i = 0; i < expectedByteCount; i++)
//	{
//		if ((*bytecode)[i] != expectedBytecode[i])
//		{
//			passed = false;
//
//			std::cout << "At bytecode address " << std::hex << std::setw(4) << std::setfill('0') << i << std::endl;
//			std::cout << "Got: " << std::hex << std::setw(2) << std::setfill('0') << static_cast<uint32_t>((*bytecode)[i]) << std::endl;
//			std::cout << "Expected: " << std::hex << std::setw(2) << std::setfill('0') << static_cast<uint32_t>(expectedBytecode[i]) << std::endl;
//		}
//	}
//
//	std::cout << std::dec;
//
//	if (passed)
//	{
//		std::cout << testSuite[filename].testname << " ... PASSED" << std::endl;
//
//		if (logFile.is_open())
//			logFile << testSuite[filename].testname << " ... PASSED" << std::endl << std::endl;
//	}
//	else
//	{
//		std::cout << testSuite[filename].testname << " ... FAILED" << std::endl;
//
//		if (logFile.is_open())
//			logFile << testSuite[filename].testname << " ... FAILED" << std::endl << std::endl;
//	}
//}